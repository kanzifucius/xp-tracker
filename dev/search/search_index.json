{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"xp-tracker","text":"<p>A minimal, read-only Prometheus exporter for Crossplane claims and composite resources (XRs).</p> <p>It polls the Kubernetes API via the dynamic client, aggregates resource counts by meaningful labels, and exposes them as Prometheus gauge metrics on <code>/metrics</code>.</p>"},{"location":"#why-xp-tracker","title":"Why xp-tracker?","text":""},{"location":"#the-gap-in-standard-crossplane-metrics","title":"The gap in standard Crossplane metrics","text":"<p>Crossplane ships with controller-level Prometheus metrics out of the box -- reconcile duration, workqueue depth, API request latency, and similar operational signals. These are valuable for monitoring the health of the Crossplane controllers themselves, but they don't answer the questions platform teams actually ask:</p> <ul> <li>How many claims exist per namespace?</li> <li>Who created them?</li> <li>Which team owns them?</li> <li>Which compositions are most popular?</li> <li>Is adoption growing over time?</li> </ul> <p>Standard Crossplane metrics have no concept of creator, team, composition breakdown, or per-namespace inventory counts. That is the gap xp-tracker fills.</p>"},{"location":"#what-xp-tracker-adds","title":"What xp-tracker adds","text":"Business-level dimensions Every metric is broken down by <code>creator</code>, <code>team</code>, <code>namespace</code>, and <code>composition</code>. These are the dimensions that matter when you're running a platform, not just an operator. Inventory and adoption tracking Get real answers to \"how many claims of each type exist?\", \"which namespaces are using the platform?\", and \"which compositions are most adopted?\" -- all via standard PromQL queries and Grafana dashboards. Chargeback and showback The <code>creator</code> + <code>team</code> + <code>namespace</code> labels make it straightforward to build cost-allocation or usage-reporting dashboards per team or business unit. Dynamic, zero-codegen Works with any Crossplane CRD without code generation or recompilation. Just configure your GVRs as environment variables and deploy. JSON bookkeeping endpoint Beyond Prometheus, the <code>/bookkeeping</code> endpoint returns a full snapshot of all tracked resources as JSON. Useful for CLI tooling, external integrations, audit trails, or any consumer that doesn't want to go through PromQL."},{"location":"#standard-crossplane-metrics-vs-xp-tracker","title":"Standard Crossplane metrics vs xp-tracker","text":"Dimension Crossplane built-in xp-tracker Reconcile latency / errors -- Workqueue depth -- Claim count by namespace -- Claim count by creator -- Claim count by team -- Readiness ratio by composition -- XR count by kind / composition -- JSON resource inventory -- <p>In short</p> <p>Crossplane tells you how the controller is doing. xp-tracker tells you what resources exist, who owns them, and whether they're healthy -- the information platform teams need to run an internal developer platform.</p>"},{"location":"#pairs-well-with-kindplane","title":"Pairs well with kindplane","text":"<p>kindplane is a companion CLI tool that bootstraps Kind clusters pre-configured with Crossplane, cloud providers, and Helm charts -- all with a single command. If you're evaluating xp-tracker or developing Crossplane compositions locally, kindplane is the fastest way to get a working environment:</p> <pre><code># One command to get a local Crossplane cluster\nkindplane up\n\n# Deploy xp-tracker and start exploring metrics\nkubectl apply -k deploy/base\ncurl -s localhost:8080/metrics | grep crossplane_\n</code></pre> <p>Together, the two tools cover the full local platform-engineering workflow: kindplane provisions the cluster and Crossplane stack, xp-tracker gives you visibility into the resources running on it.</p>"},{"location":"#how-it-works","title":"How it works","text":"<pre><code>graph TD\n    A[Kubernetes API] --&gt;|List / Watch| B[Poller&lt;br/&gt;&lt;small&gt;pkg/kube&lt;/small&gt;]\n    B --&gt;|ReplaceClaims / ReplaceXRs&lt;br/&gt;EnrichClaimCompositions| C[In-Memory Store&lt;br/&gt;&lt;small&gt;pkg/store&lt;/small&gt;]\n    C --&gt;|SnapshotClaims / SnapshotXRs| D[Claim &amp; XR Collectors&lt;br/&gt;&lt;small&gt;pkg/metrics&lt;/small&gt;]\n    D --&gt; E[HTTP Server&lt;br/&gt;&lt;small&gt;pkg/server&lt;/small&gt;]\n    E --&gt;|GET /metrics| F[Prometheus]\n    E --&gt;|GET /bookkeeping| G[JSON consumers&lt;br/&gt;&lt;small&gt;CLI tools, dashboards&lt;/small&gt;]\n    F --&gt; H[Grafana]\n\n    style A fill:#326CE5,color:#fff,stroke:#326CE5\n    style F fill:#E6522C,color:#fff,stroke:#E6522C\n    style H fill:#F46800,color:#fff,stroke:#F46800</code></pre>"},{"location":"#key-features","title":"Key features","text":"<ul> <li> Read-only -- only <code>get</code>, <code>list</code>, and <code>watch</code> operations against the Kubernetes API. Never creates, updates, or deletes resources.</li> <li> Dynamic client -- works with any Crossplane CRD without code generation. Configure GVRs via environment variables.</li> <li> Claim metrics -- total and ready counts broken down by group, kind, namespace, composition, creator, and team.</li> <li> XR metrics -- total and ready counts broken down by group, kind, namespace, and composition.</li> <li> Composition enrichment -- claims are enriched with their composition name by following <code>spec.resourceRef</code> to the backing XR.</li> <li> Bookkeeping endpoint -- JSON snapshot of all tracked resources at <code>GET /bookkeeping</code> for debugging and integrations.</li> <li> Pluggable store -- the in-memory data layer is behind a <code>store.Store</code> interface. An S3-backed persistent store is included for surviving restarts.</li> <li> Lightweight -- single binary, ~10 MB distroless container image, minimal resource footprint.</li> <li> Multi-arch -- container images built for <code>linux/amd64</code> and <code>linux/arm64</code>.</li> </ul>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li> <p> Installation</p> <p>Get xp-tracker running in your cluster</p> </li> <li> <p> Configuration</p> <p>All environment variables and their defaults</p> </li> <li> <p> Metrics Reference</p> <p>The four Prometheus gauges and their labels</p> </li> <li> <p> Deployment</p> <p>Kustomize base and overlays</p> </li> <li> <p> Bookkeeping API</p> <p>JSON endpoint for debugging and integrations</p> </li> <li> <p> Grafana Queries</p> <p>Example PromQL queries for dashboards</p> </li> </ul>"},{"location":"api/bookkeeping/","title":"Bookkeeping Endpoint","text":"<p>In addition to Prometheus metrics, xp-tracker exposes a JSON endpoint that returns the full in-memory snapshot of claims and XRs. This is useful for ad-hoc debugging, CLI tools, or external integrations that don't want to go through PromQL.</p>"},{"location":"api/bookkeeping/#endpoint","title":"Endpoint","text":"<pre><code>GET /bookkeeping\n</code></pre> <p>Returns <code>Content-Type: application/json; charset=utf-8</code> with HTTP 200.</p>"},{"location":"api/bookkeeping/#response-format","title":"Response format","text":"<pre><code>{\n  \"claims\": [\n    {\n      \"group\": \"platform.example.org\",\n      \"kind\": \"PostgreSQLInstance\",\n      \"namespace\": \"team-a\",\n      \"name\": \"db-123\",\n      \"creator\": \"alice@example.com\",\n      \"team\": \"payments\",\n      \"composition\": \"postgres-small\",\n      \"ready\": true,\n      \"reason\": \"Ready\",\n      \"ageSeconds\": 12345\n    }\n  ],\n  \"xrs\": [\n    {\n      \"group\": \"platform.example.org\",\n      \"kind\": \"XPostgreSQLInstance\",\n      \"namespace\": \"\",\n      \"name\": \"db-123-xyz\",\n      \"composition\": \"postgres-small\",\n      \"ready\": true,\n      \"reason\": \"Ready\",\n      \"ageSeconds\": 12300\n    }\n  ],\n  \"generatedAt\": \"2026-02-13T20:50:00Z\"\n}\n</code></pre>"},{"location":"api/bookkeeping/#fields","title":"Fields","text":""},{"location":"api/bookkeeping/#claim-fields","title":"Claim fields","text":"Field Type Description <code>group</code> string API group from the GVR <code>kind</code> string Resource kind <code>namespace</code> string Kubernetes namespace <code>name</code> string Resource name <code>creator</code> string Value of the creator annotation (empty if not set) <code>team</code> string Value of the team annotation (empty if not set) <code>composition</code> string Composition name (enriched from backing XR) <code>ready</code> boolean Whether the Ready condition is True <code>reason</code> string Ready condition reason <code>ageSeconds</code> integer Seconds since <code>metadata.creationTimestamp</code>"},{"location":"api/bookkeeping/#xr-fields","title":"XR fields","text":"Field Type Description <code>group</code> string API group from the GVR <code>kind</code> string Resource kind <code>namespace</code> string Namespace (usually empty for cluster-scoped XRs) <code>name</code> string Resource name <code>composition</code> string Composition name (from label) <code>ready</code> boolean Whether the Ready condition is True <code>reason</code> string Ready condition reason <code>ageSeconds</code> integer Seconds since <code>metadata.creationTimestamp</code>"},{"location":"api/bookkeeping/#top-level-fields","title":"Top-level fields","text":"Field Type Description <code>generatedAt</code> string ISO 8601 / RFC 3339 UTC timestamp of when the response was generated"},{"location":"api/bookkeeping/#usage-examples","title":"Usage examples","text":"<pre><code># Full snapshot\ncurl -s localhost:8080/bookkeeping | jq .\n\n# Count claims by namespace\ncurl -s localhost:8080/bookkeeping | jq '[.claims[] | .namespace] | group_by(.) | map({(.[0]): length}) | add'\n\n# List not-ready claims\ncurl -s localhost:8080/bookkeeping | jq '[.claims[] | select(.ready == false)]'\n\n# Get all XR compositions\ncurl -s localhost:8080/bookkeeping | jq '[.xrs[].composition] | unique'\n</code></pre>"},{"location":"api/bookkeeping/#notes","title":"Notes","text":"<ul> <li>The endpoint reflects the last completed polling cycle and is eventually consistent.</li> <li>No authentication is required. The endpoint is intended for cluster-internal use. Restrict access via Kubernetes NetworkPolicy if needed.</li> <li>In large clusters the payload may be substantial. Pagination and filtering may be added in future versions.</li> </ul>"},{"location":"configuration/environment-variables/","title":"Environment Variables","text":"<p>All xp-tracker configuration is via environment variables. There are no config files or command-line flags.</p>"},{"location":"configuration/environment-variables/#reference","title":"Reference","text":"Variable Required Default Description <code>CLAIM_GVRS</code> Yes -- Comma-separated claim GVRs in <code>group/version/resource</code> format <code>XR_GVRS</code> Yes -- Comma-separated XR GVRs in <code>group/version/resource</code> format <code>KUBE_NAMESPACE_SCOPE</code> No <code>\"\"</code> (all) Comma-separated namespace filter <code>CREATOR_ANNOTATION_KEY</code> No <code>\"\"</code> Annotation key for claim creator attribution <code>TEAM_ANNOTATION_KEY</code> No <code>\"\"</code> Annotation key for team attribution <code>COMPOSITION_LABEL_KEY</code> No <code>crossplane.io/composition-name</code> Label key on XRs for composition name <code>POLL_INTERVAL_SECONDS</code> No <code>30</code> Seconds between polling cycles <code>METRICS_ADDR</code> No <code>:8080</code> Listen address for the HTTP metrics server <code>STORE_BACKEND</code> No <code>memory</code> Persistent store backend: <code>memory</code> or <code>s3</code> <code>S3_BUCKET</code> When <code>s3</code> <code>\"\"</code> S3 bucket name <code>S3_KEY_PREFIX</code> No <code>xp-tracker</code> S3 key prefix for snapshot file <code>S3_REGION</code> No <code>us-east-1</code> AWS region for S3 client <code>S3_ENDPOINT</code> No <code>\"\"</code> Custom S3 endpoint (MinIO, LocalStack)"},{"location":"configuration/environment-variables/#gvr-format","title":"GVR format","text":"<p>Each GVR must be specified in <code>group/version/resource</code> format. The resource name is the plural lowercase form (the same string you'd use with <code>kubectl get</code>).</p> <pre><code>CLAIM_GVRS=\"platform.example.org/v1alpha1/postgresqlinstances,platform.example.org/v1alpha1/kafkatopics\"\nXR_GVRS=\"platform.example.org/v1alpha1/xpostgresqlinstances,platform.example.org/v1alpha1/xkafkatopics\"\n</code></pre> <p>Finding your GVRs</p> <p>Use <code>kubectl api-resources</code> to find the correct group, version, and resource name for your Crossplane types:</p> <pre><code>kubectl api-resources | grep platform.example.org\n</code></pre>"},{"location":"configuration/environment-variables/#namespace-filtering","title":"Namespace filtering","text":"<p>By default, xp-tracker polls all namespaces. To restrict to specific namespaces:</p> <pre><code>KUBE_NAMESPACE_SCOPE=\"team-a,team-b,team-c\"\n</code></pre> <p>Note</p> <p>Namespace filtering only applies to namespace-scoped resources (claims). Cluster-scoped XRs are always polled globally.</p>"},{"location":"configuration/environment-variables/#annotation-keys","title":"Annotation keys","text":"<p>The <code>CREATOR_ANNOTATION_KEY</code> and <code>TEAM_ANNOTATION_KEY</code> variables tell xp-tracker which annotations on claims contain the creator and team information. These are used as Prometheus labels for attribution-based queries.</p> <pre><code>CREATOR_ANNOTATION_KEY=\"myorg.io/created-by\"\nTEAM_ANNOTATION_KEY=\"myorg.io/team\"\n</code></pre> <p>If the annotation is not present on a claim, the label value will be an empty string.</p>"},{"location":"configuration/environment-variables/#composition-label","title":"Composition label","text":"<p>The <code>COMPOSITION_LABEL_KEY</code> tells xp-tracker which label on XRs contains the Composition name. The default (<code>crossplane.io/composition-name</code>) works with standard Crossplane installations.</p> <p>Claims get their composition value through a two-step enrichment:</p> <ol> <li>The claim's <code>spec.resourceRef.name</code> identifies the backing XR</li> <li>The XR's composition label value is copied to the claim</li> </ol>"},{"location":"configuration/environment-variables/#deployment-via-configmap","title":"Deployment via ConfigMap","text":"<p>In the Kustomize manifests, environment variables are stored in a ConfigMap and injected via <code>envFrom</code>:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: crossplane-metrics-exporter\ndata:\n  CLAIM_GVRS: \"platform.example.org/v1alpha1/postgresqlinstances\"\n  XR_GVRS: \"platform.example.org/v1alpha1/xpostgresqlinstances\"\n  CREATOR_ANNOTATION_KEY: \"platform.example.org/created-by\"\n  TEAM_ANNOTATION_KEY: \"platform.example.org/team\"\n  POLL_INTERVAL_SECONDS: \"30\"\n  METRICS_ADDR: \":8080\"\n</code></pre>"},{"location":"configuration/store-backends/","title":"Store Backends","text":"<p>xp-tracker uses a pluggable store interface for holding claim and XR metadata in memory. By default, data lives only in memory and is lost on restart. For workloads that restart frequently, an S3 persistent backend is available.</p>"},{"location":"configuration/store-backends/#store-interface","title":"Store interface","text":"<p>The <code>store.Store</code> interface defines 7 methods:</p> <pre><code>type Store interface {\n    ReplaceClaims(gvr string, items []ClaimInfo)\n    ReplaceXRs(gvr string, items []XRInfo)\n    EnrichClaimCompositions()\n    SnapshotClaims() []ClaimInfo\n    SnapshotXRs() []XRInfo\n    ClaimCount() int\n    XRCount() int\n}\n</code></pre> <p>All implementations must be safe for concurrent use.</p>"},{"location":"configuration/store-backends/#memory-store-default","title":"Memory store (default)","text":"<p>The default <code>MemoryStore</code> is a thread-safe in-memory store backed by Go maps and a <code>sync.RWMutex</code>. It requires no configuration.</p> <pre><code>STORE_BACKEND=memory  # or simply omit the variable\n</code></pre> <p>Trade-offs:</p> <ul> <li>Fast reads and writes</li> <li>No external dependencies</li> <li>Data is lost on pod restart -- the next poll cycle repopulates it (default: 30 seconds)</li> </ul>"},{"location":"configuration/store-backends/#s3-persistent-store","title":"S3 persistent store","text":"<p>The <code>S3Store</code> wraps <code>MemoryStore</code> with S3 persistence using a decorator pattern. All reads are served from memory (so Prometheus scraping stays fast). After each poll cycle, the in-memory snapshot is serialised to S3. On startup, the store restores from S3 before the first poll.</p> <pre><code>STORE_BACKEND=s3\nS3_BUCKET=my-xp-tracker-bucket\nS3_KEY_PREFIX=xp-tracker          # optional, default: xp-tracker\nS3_REGION=us-east-1               # optional, default: us-east-1\nS3_ENDPOINT=http://minio:9000     # optional, for S3-compatible providers\n</code></pre>"},{"location":"configuration/store-backends/#how-it-works","title":"How it works","text":"<ol> <li>Startup: attempts to restore from <code>s3://&lt;bucket&gt;/&lt;prefix&gt;/snapshot.json</code></li> <li>Each poll cycle: writes the full snapshot to the same S3 key (overwrite)</li> <li>If S3 is unreachable at startup: starts with an empty store and logs a warning</li> </ol>"},{"location":"configuration/store-backends/#authentication","title":"Authentication","text":"<p>The S3 client uses the AWS SDK v2 default credential chain, which supports:</p> <ul> <li>IAM roles for service accounts (IRSA) -- recommended for EKS</li> <li>Environment variables (<code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>)</li> <li>Shared credentials file (<code>~/.aws/credentials</code>)</li> <li>EC2 instance metadata</li> </ul>"},{"location":"configuration/store-backends/#s3-compatible-providers","title":"S3-compatible providers","text":"<p>Set <code>S3_ENDPOINT</code> to use MinIO, LocalStack, or any S3-compatible API:</p> <pre><code>S3_ENDPOINT=http://minio.minio.svc:9000\n</code></pre> <p>Path-style addressing is automatically enabled when a custom endpoint is set.</p>"},{"location":"configuration/store-backends/#snapshot-format","title":"Snapshot format","text":"<p>The snapshot is a single JSON file containing all claims and XRs:</p> <pre><code>{\n  \"claims\": [...],\n  \"xrs\": [...],\n  \"persistedAt\": \"2026-02-15T10:00:00Z\"\n}\n</code></pre>"},{"location":"configuration/store-backends/#implementing-a-custom-backend","title":"Implementing a custom backend","text":"<p>To add a new persistent backend (e.g., DynamoDB, PostgreSQL), implement the <code>PersistentStore</code> interface:</p> <pre><code>type PersistentStore interface {\n    Store\n    Persist(ctx context.Context) error  // called after each poll cycle\n    Restore(ctx context.Context) error  // called once at startup\n}\n</code></pre> <p>The recommended approach is the decorator pattern: wrap <code>MemoryStore</code>, delegate all <code>Store</code> methods to it, and add persistence in <code>Persist</code>/<code>Restore</code>. See <code>pkg/store/s3store.go</code> for a reference implementation.</p>"},{"location":"deployment/kustomize/","title":"Kustomize Deployment","text":"<p>xp-tracker ships with Kustomize manifests organised as a base plus overlays.</p>"},{"location":"deployment/kustomize/#base","title":"Base","text":"<p>The base at <code>deploy/base/</code> includes:</p> Manifest Description <code>serviceaccount.yaml</code> ServiceAccount for the exporter pod <code>clusterrole.yaml</code> ClusterRole with read-only access (see RBAC) <code>clusterrolebinding.yaml</code> Binds the ClusterRole to the ServiceAccount <code>configmap.yaml</code> Environment variables for the exporter <code>deployment.yaml</code> Single-replica Deployment <code>service.yaml</code> Service exposing port 8080 (<code>metrics</code>) <p>The base deploys to the <code>crossplane-system</code> namespace and includes placeholder GVRs that must be overridden.</p> <pre><code># Review rendered manifests\nkubectl kustomize deploy/base\n\n# Apply\nkubectl apply -k deploy/base\n</code></pre>"},{"location":"deployment/kustomize/#example-overlay","title":"Example overlay","text":"<p>The example overlay at <code>deploy/overlays/example/</code> demonstrates:</p> <ul> <li>Patching the ConfigMap with real GVRs and annotation keys</li> <li>Adding a <code>ServiceMonitor</code> for Prometheus Operator</li> <li>Pinning the container image tag</li> </ul> <pre><code>kubectl apply -k deploy/overlays/example\n</code></pre>"},{"location":"deployment/kustomize/#creating-your-own-overlay","title":"Creating your own overlay","text":"<p>Create a directory for your environment:</p> <pre><code>deploy/overlays/my-env/\n  kustomization.yaml\n</code></pre> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nresources:\n  - ../../base\n\npatches:\n  - target:\n      kind: ConfigMap\n      name: crossplane-metrics-exporter\n    patch: |\n      apiVersion: v1\n      kind: ConfigMap\n      metadata:\n        name: crossplane-metrics-exporter\n      data:\n        CLAIM_GVRS: \"myorg.io/v1alpha1/databases,myorg.io/v1alpha1/caches\"\n        XR_GVRS: \"myorg.io/v1alpha1/xdatabases,myorg.io/v1alpha1/xcaches\"\n        CREATOR_ANNOTATION_KEY: \"myorg.io/created-by\"\n        TEAM_ANNOTATION_KEY: \"myorg.io/team\"\n\nimages:\n  - name: ghcr.io/kanzifucius/xp-tracker\n    newTag: v0.1.0\n</code></pre>"},{"location":"deployment/kustomize/#namespace","title":"Namespace","text":"<p>The base sets <code>namespace: crossplane-system</code>. To deploy to a different namespace, add a <code>namespace</code> field in your overlay's <code>kustomization.yaml</code>:</p> <pre><code>namespace: monitoring\n</code></pre>"},{"location":"deployment/kustomize/#image-override","title":"Image override","text":"<p>Use the Kustomize <code>images</code> transformer to pin a specific tag:</p> <pre><code>images:\n  - name: ghcr.io/kanzifucius/xp-tracker\n    newTag: v0.2.0\n</code></pre>"},{"location":"deployment/kustomize/#single-replica-requirement","title":"Single replica requirement","text":"<p>Warning</p> <p>Running more than one replica will result in double-counted metrics since each replica independently polls and serves metrics. Always keep <code>replicas: 1</code>.</p>"},{"location":"deployment/prometheus/","title":"Prometheus Scraping","text":"<p>xp-tracker exposes metrics on <code>GET /metrics</code> (port 8080 by default). There are two main approaches to scraping.</p>"},{"location":"deployment/prometheus/#scrape-configuration","title":"Scrape configuration","text":"ServiceMonitor (Prometheus Operator)Scrape Config (Direct) <p>If you use the Prometheus Operator, add a <code>ServiceMonitor</code> to your Kustomize overlay. The example overlay at <code>deploy/overlays/example/</code> includes one:</p> <pre><code>apiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: crossplane-metrics-exporter\n  labels:\n    app.kubernetes.io/name: crossplane-metrics-exporter\n    app.kubernetes.io/component: exporter\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: crossplane-metrics-exporter\n  endpoints:\n    - port: metrics\n      interval: 30s\n      path: /metrics\n</code></pre> <p>Prometheus selector configuration</p> <p>If your Prometheus instance uses <code>serviceMonitorSelector</code>, make sure the ServiceMonitor labels match. If using kube-prometheus-stack, you may need to set <code>serviceMonitorSelectorNilUsesHelmValues: false</code> in your Prometheus Helm values so it discovers all ServiceMonitors regardless of labels.</p> <p>Add a scrape config directly to your <code>prometheus.yml</code>:</p> <pre><code>scrape_configs:\n  - job_name: crossplane-metrics-exporter\n    kubernetes_sd_configs:\n      - role: endpoints\n        namespaces:\n          names:\n            - crossplane-system\n    relabel_configs:\n      - source_labels: [__meta_kubernetes_service_name]\n        regex: crossplane-metrics-exporter\n        action: keep\n      - source_labels: [__meta_kubernetes_endpoint_port_name]\n        regex: metrics\n        action: keep\n</code></pre>"},{"location":"deployment/prometheus/#scrape-interval","title":"Scrape interval","text":"<p>Set the scrape interval to match or exceed your <code>POLL_INTERVAL_SECONDS</code> (default: 30s). Scraping faster than the poll interval won't provide more data -- the metrics are recomputed from the in-memory store on each scrape, and the store is only updated on each poll cycle.</p>"},{"location":"deployment/prometheus/#verifying","title":"Verifying","text":"<p>Port-forward to the exporter and check the metrics endpoint:</p> <pre><code>kubectl -n crossplane-system port-forward svc/crossplane-metrics-exporter 8080:8080\ncurl -s localhost:8080/metrics | grep crossplane_\n</code></pre> <p>You should see the four gauge metrics: <code>crossplane_claims_total</code>, <code>crossplane_claims_ready</code>, <code>crossplane_xr_total</code>, <code>crossplane_xr_ready</code>.</p>"},{"location":"deployment/rbac/","title":"RBAC","text":"<p>xp-tracker needs read-only access to the Crossplane claim and XR resources it polls.</p>"},{"location":"deployment/rbac/#default-clusterrole","title":"Default ClusterRole","text":"<p>The base Kustomize manifests include a ClusterRole with broad read access:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: crossplane-metrics-exporter\nrules:\n  - apiGroups: [\"*\"]\n    resources: [\"*\"]\n    verbs: [\"get\", \"list\", \"watch\"]\n</code></pre> <p>This permissive rule is convenient for getting started but should be scoped down for production.</p>"},{"location":"deployment/rbac/#scoping-for-production","title":"Scoping for production","text":"<p>Restrict the ClusterRole to only the specific API groups and resources you need. For example, if you track <code>postgresqlinstances</code> and <code>kafkatopics</code>:</p> <pre><code>rules:\n  - apiGroups: [\"platform.example.org\"]\n    resources:\n      - postgresqlinstances\n      - xpostgresqlinstances\n      - kafkatopics\n      - xkafkatopics\n    verbs: [\"get\", \"list\", \"watch\"]\n</code></pre> <p>Tip</p> <p>Include both the claim resources and the XR resources. The exporter needs to read XRs to enrich claims with composition information.</p> <p>You can override the ClusterRole via a Kustomize patch in your overlay:</p> <pre><code>patches:\n  - target:\n      kind: ClusterRole\n      name: crossplane-metrics-exporter\n    patch: |\n      apiVersion: rbac.authorization.k8s.io/v1\n      kind: ClusterRole\n      metadata:\n        name: crossplane-metrics-exporter\n      rules:\n        - apiGroups: [\"platform.example.org\"]\n          resources:\n            - postgresqlinstances\n            - xpostgresqlinstances\n          verbs: [\"get\", \"list\", \"watch\"]\n</code></pre>"},{"location":"deployment/rbac/#binding","title":"Binding","text":"<p>The ClusterRoleBinding binds the ClusterRole to the <code>crossplane-metrics-exporter</code> ServiceAccount in the <code>crossplane-system</code> namespace:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: crossplane-metrics-exporter\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: crossplane-metrics-exporter\nsubjects:\n  - kind: ServiceAccount\n    name: crossplane-metrics-exporter\n    namespace: crossplane-system\n</code></pre>"},{"location":"deployment/rbac/#why-read-only","title":"Why read-only?","text":"<p>xp-tracker is strictly a metrics exporter. It never creates, updates, or deletes resources. The <code>get</code>, <code>list</code>, and <code>watch</code> verbs are the minimum required to poll the API server for resource metadata.</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to xp-tracker.</p> <p>For the full contributing guide -- including development setup, PR process, commit conventions, and code style -- see the CONTRIBUTING.md file in the repository root.</p>"},{"location":"development/contributing/#quick-links","title":"Quick links","text":"<ul> <li>Development setup -- get a local environment running</li> <li>CONTRIBUTING.md -- full contributing guide</li> <li>Code of Conduct -- community standards</li> <li>Security Policy -- reporting vulnerabilities</li> <li>Open Issues -- find something to work on</li> </ul>"},{"location":"development/local-setup/","title":"Local Development Setup","text":""},{"location":"development/local-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25+ (or use mise: <code>mise install</code>)</li> <li>Docker (for container builds)</li> <li>kubectl</li> <li>kindplane (recommended for local dev)</li> <li>golangci-lint for linting</li> </ul>"},{"location":"development/local-setup/#cluster-setup","title":"Cluster setup","text":"kindplane (Recommended)Manual Kind Setup <p>kindplane bootstraps Kind clusters pre-configured with Crossplane and providers. This repo includes a <code>kindplane.yaml</code> that sets up:</p> <ul> <li>Kind cluster named <code>xp-tracker-dev</code></li> <li>Crossplane 2.0 with <code>provider-kubernetes</code> and <code>provider-nop</code></li> <li>kube-prometheus-stack (Grafana on NodePort 30300)</li> <li>Sample XRDs, Compositions, and Claims under <code>hack/samples/</code></li> </ul> <pre><code># Install kindplane\ncurl -fsSL https://raw.githubusercontent.com/kanzifucius/kindplane/main/install.sh | bash\n\n# Create the cluster (uses kindplane.yaml in repo root)\nkindplane up\n\n# Apply sample resources (8 claims across 3 namespaces, 5 creators, 3 teams)\nmake samples-apply\n\n# Run the exporter against the sample resources\nmake run-local\n\n# In another terminal -- check metrics\ncurl -s localhost:8080/metrics | grep crossplane_\n\n# Check bookkeeping\ncurl -s localhost:8080/bookkeeping | jq .\n\n# Clean up\nmake samples-delete\nkindplane down\n</code></pre> <p>If you prefer to set up the cluster manually without kindplane:</p> <pre><code># Create a cluster\nkind create cluster --name xp-dev\n\n# Install Crossplane\nhelm repo add crossplane-stable https://charts.crossplane.io/stable\nhelm install crossplane crossplane-stable/crossplane \\\n  --namespace crossplane-system --create-namespace\n\n# Install your XRDs and Compositions, then create some claims\n\n# Run the exporter locally\nexport CLAIM_GVRS=\"your.org/v1alpha1/yourclaims\"\nexport XR_GVRS=\"your.org/v1alpha1/yourxrs\"\nmake run\n</code></pre>"},{"location":"development/local-setup/#build-and-run","title":"Build and run","text":"<pre><code># Build the binary\nmake build\n\n# Run against a local cluster (uses KUBECONFIG or ~/.kube/config)\nexport CLAIM_GVRS=\"samples.xptracker.dev/v1alpha1/widgets,samples.xptracker.dev/v1alpha1/gadgets\"\nexport XR_GVRS=\"samples.xptracker.dev/v1alpha1/xwidgets,samples.xptracker.dev/v1alpha1/xgadgets\"\nexport CREATOR_ANNOTATION_KEY=\"xptracker.dev/created-by\"\nexport TEAM_ANNOTATION_KEY=\"xptracker.dev/team\"\nexport POLL_INTERVAL_SECONDS=10\n./bin/xp-tracker\n</code></pre>"},{"location":"development/local-setup/#testing","title":"Testing","text":"Command Description <code>make test</code> Run tests with race detector <code>make lint</code> Run golangci-lint <code>make vet</code> Run <code>go vet</code> <code>make check</code> Run all checks (vet + lint + test)"},{"location":"development/local-setup/#docker","title":"Docker","text":"<pre><code># Build (defaults to ghcr.io/kanzifucius/xp-tracker:latest)\nmake docker-build\n\n# Override image/tag\nmake docker-build IMAGE=myregistry.io/xp-tracker TAG=v0.1.0\n\n# Push\nmake docker-push IMAGE=myregistry.io/xp-tracker TAG=v0.1.0\n</code></pre>"},{"location":"development/local-setup/#tool-versions","title":"Tool versions","text":"<p>The project uses mise for tool version pinning via <code>.mise.toml</code>:</p> Tool Version Go 1.25.5 golangci-lint 1.64.8 kubectl 1.34.2 <p>Run <code>mise install</code> to install the pinned versions.</p>"},{"location":"development/local-setup/#makefile-targets","title":"Makefile targets","text":"<p>Run <code>make help</code> to see all available targets. Key groups:</p> <ul> <li>build -- <code>build</code>, <code>clean</code></li> <li>test -- <code>test</code>, <code>lint</code>, <code>vet</code>, <code>check</code></li> <li>docker -- <code>docker-build</code>, <code>docker-push</code></li> <li>deploy -- <code>deploy</code>, <code>undeploy</code></li> <li>dev -- <code>dev</code>, <code>run</code>, <code>run-local</code></li> <li>samples -- <code>samples-apply</code>, <code>samples-delete</code></li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#container-image","title":"Container image","text":"<p>xp-tracker is distributed as a multi-arch container image on GitHub Container Registry:</p> <pre><code>docker pull ghcr.io/kanzifucius/xp-tracker:latest\n</code></pre> <p>Supported architectures: <code>linux/amd64</code>, <code>linux/arm64</code>.</p>"},{"location":"getting-started/installation/#deploy-or-build","title":"Deploy or build","text":"Kustomize BaseKustomize OverlayBuild from Source <p>The recommended way to deploy xp-tracker. The base deploys to the <code>crossplane-system</code> namespace with placeholder GVRs that you must override:</p> <pre><code># Review what will be applied\nkubectl kustomize deploy/base\n\n# Apply\nkubectl apply -k deploy/base\n</code></pre> <p>The example overlay demonstrates how to customise GVRs, add a ServiceMonitor, and pin the image tag:</p> <pre><code>kubectl apply -k deploy/overlays/example\n</code></pre> <p>See Kustomize deployment for details on creating your own overlay.</p> <p>Requires Go 1.25+:</p> <pre><code>git clone https://github.com/kanzifucius/xp-tracker.git\ncd xp-tracker\nmake build\n</code></pre> <p>The binary is output to <code>bin/xp-tracker</code>.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kubernetes cluster with Crossplane installed</li> <li>Crossplane CRDs (XRDs) and Compositions deployed</li> <li><code>kubectl</code> with access to the cluster</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide takes you from zero to seeing Crossplane metrics in under five minutes.</p>"},{"location":"getting-started/quickstart/#1-deploy-xp-tracker","title":"1. Deploy xp-tracker","text":"<p>Create a Kustomize overlay for your environment:</p> <pre><code>deploy/overlays/my-env/\n  kustomization.yaml\n</code></pre> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nresources:\n  - ../../base\n\npatches:\n  - target:\n      kind: ConfigMap\n      name: crossplane-metrics-exporter\n    patch: |\n      apiVersion: v1\n      kind: ConfigMap\n      metadata:\n        name: crossplane-metrics-exporter\n      data:\n        CLAIM_GVRS: \"myorg.io/v1alpha1/databases,myorg.io/v1alpha1/caches\"\n        XR_GVRS: \"myorg.io/v1alpha1/xdatabases,myorg.io/v1alpha1/xcaches\"\n        CREATOR_ANNOTATION_KEY: \"myorg.io/created-by\"\n        TEAM_ANNOTATION_KEY: \"myorg.io/team\"\n\nimages:\n  - name: ghcr.io/kanzifucius/xp-tracker\n    newTag: latest\n</code></pre> <p>Apply it:</p> <pre><code>kubectl apply -k deploy/overlays/my-env\n</code></pre>"},{"location":"getting-started/quickstart/#2-verify-the-exporter-is-running","title":"2. Verify the exporter is running","text":"<pre><code>kubectl -n crossplane-system get pods -l app.kubernetes.io/name=crossplane-metrics-exporter\n</code></pre>"},{"location":"getting-started/quickstart/#3-check-metrics","title":"3. Check metrics","text":"<p>Port-forward to the exporter:</p> <pre><code>kubectl -n crossplane-system port-forward svc/crossplane-metrics-exporter 8080:8080\n</code></pre> <p>Then query the metrics endpoint:</p> <pre><code>curl -s localhost:8080/metrics | grep crossplane_\n</code></pre> <p>You should see output like:</p> <pre><code># HELP crossplane_claims_total Number of Crossplane claims by group, kind, namespace, composition and creator.\n# TYPE crossplane_claims_total gauge\ncrossplane_claims_total{composition=\"db-small\",creator=\"alice@example.com\",group=\"myorg.io\",kind=\"Database\",namespace=\"team-a\",team=\"platform\"} 3\n</code></pre>"},{"location":"getting-started/quickstart/#4-check-bookkeeping","title":"4. Check bookkeeping","text":"<p>The JSON bookkeeping endpoint provides a full snapshot of all tracked resources:</p> <pre><code>curl -s localhost:8080/bookkeeping | jq .\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next steps","text":"<ul> <li>Configure environment variables to tune polling, namespaces, and annotation keys</li> <li>Set up Prometheus scraping for production monitoring</li> <li>Build Grafana dashboards with example PromQL queries</li> </ul>"},{"location":"includes/abbreviations/","title":"Abbreviations","text":""},{"location":"metrics/grafana-queries/","title":"Grafana Queries","text":"<p>Example PromQL queries for building Grafana dashboards with xp-tracker metrics.</p>"},{"location":"metrics/grafana-queries/#claim-queries","title":"Claim queries","text":""},{"location":"metrics/grafana-queries/#total-claims-by-namespace","title":"Total claims by namespace","text":"<pre><code>sum by (namespace)(crossplane_claims_total)\n</code></pre>"},{"location":"metrics/grafana-queries/#ready-claims-by-composition","title":"Ready claims by composition","text":"<pre><code>sum by (composition)(crossplane_claims_ready)\n</code></pre>"},{"location":"metrics/grafana-queries/#claims-by-creator","title":"Claims by creator","text":"<pre><code>sum by (creator)(crossplane_claims_total)\n</code></pre>"},{"location":"metrics/grafana-queries/#claim-readiness-ratio-by-namespace","title":"Claim readiness ratio by namespace","text":"<pre><code>sum by (namespace)(crossplane_claims_ready) / sum by (namespace)(crossplane_claims_total)\n</code></pre> <p>Tip</p> <p>Use this with a Grafana stat panel and percentage unit to show a readiness percentage per namespace.</p>"},{"location":"metrics/grafana-queries/#not-ready-claims-by-namespace","title":"Not-ready claims by namespace","text":"<pre><code>sum by (namespace)(crossplane_claims_total) - sum by (namespace)(crossplane_claims_ready)\n</code></pre>"},{"location":"metrics/grafana-queries/#claims-by-team","title":"Claims by team","text":"<pre><code>sum by (team)(crossplane_claims_total)\n</code></pre>"},{"location":"metrics/grafana-queries/#top-creators-by-claim-count","title":"Top creators by claim count","text":"<pre><code>topk(10, sum by (creator)(crossplane_claims_total))\n</code></pre>"},{"location":"metrics/grafana-queries/#xr-queries","title":"XR queries","text":""},{"location":"metrics/grafana-queries/#all-xrs-grouped-by-kind","title":"All XRs grouped by kind","text":"<pre><code>sum by (kind)(crossplane_xr_total)\n</code></pre>"},{"location":"metrics/grafana-queries/#xr-readiness-ratio-by-composition","title":"XR readiness ratio by composition","text":"<pre><code>sum by (composition)(crossplane_xr_ready) / sum by (composition)(crossplane_xr_total)\n</code></pre>"},{"location":"metrics/grafana-queries/#not-ready-xrs","title":"Not-ready XRs","text":"<pre><code>sum(crossplane_xr_total) - sum(crossplane_xr_ready)\n</code></pre>"},{"location":"metrics/grafana-queries/#combined-queries","title":"Combined queries","text":""},{"location":"metrics/grafana-queries/#total-managed-resources-claims-xrs","title":"Total managed resources (claims + XRs)","text":"<pre><code>sum(crossplane_claims_total) + sum(crossplane_xr_total)\n</code></pre>"},{"location":"metrics/grafana-queries/#overall-readiness-ratio","title":"Overall readiness ratio","text":"<pre><code>(sum(crossplane_claims_ready) + sum(crossplane_xr_ready)) / (sum(crossplane_claims_total) + sum(crossplane_xr_total))\n</code></pre>"},{"location":"metrics/grafana-queries/#dashboard-tips","title":"Dashboard tips","text":"<ul> <li>Single stat panels work well for readiness ratios and total counts.</li> <li>Table panels are useful for showing per-namespace or per-team breakdowns.</li> <li>Time series panels show trends over time -- useful for spotting claim growth or readiness drops.</li> <li>Set a refresh interval that matches your <code>POLL_INTERVAL_SECONDS</code> (default: 30s) for accurate data.</li> </ul>"},{"location":"metrics/reference/","title":"Metrics Reference","text":"<p>xp-tracker exposes four Prometheus gauge metrics, recomputed on each scrape from the in-memory store.</p>"},{"location":"metrics/reference/#claim-metrics","title":"Claim metrics","text":""},{"location":"metrics/reference/#crossplane_claims_total","title":"<code>crossplane_claims_total</code>","text":"<p>Total number of Crossplane claims, broken down by label tuple.</p> Label Description <code>group</code> API group from the GVR (e.g. <code>platform.example.org</code>) <code>kind</code> Resource kind (e.g. <code>PostgresqlInstance</code>) <code>namespace</code> Kubernetes namespace <code>composition</code> Crossplane Composition name (enriched from backing XR) <code>creator</code> Value of the <code>CREATOR_ANNOTATION_KEY</code> annotation <code>team</code> Value of the <code>TEAM_ANNOTATION_KEY</code> annotation"},{"location":"metrics/reference/#crossplane_claims_ready","title":"<code>crossplane_claims_ready</code>","text":"<p>Number of Crossplane claims with <code>status.conditions</code> containing <code>type: Ready</code> and <code>status: \"True\"</code>. Same label set as <code>crossplane_claims_total</code>.</p>"},{"location":"metrics/reference/#xr-metrics","title":"XR metrics","text":""},{"location":"metrics/reference/#crossplane_xr_total","title":"<code>crossplane_xr_total</code>","text":"<p>Total number of Crossplane composite resources (XRs), broken down by label tuple.</p> Label Description <code>group</code> API group from the GVR <code>kind</code> Resource kind (e.g. <code>XPostgreSQLInstance</code>) <code>namespace</code> Kubernetes namespace (usually empty for cluster-scoped XRs) <code>composition</code> Crossplane Composition name (from <code>COMPOSITION_LABEL_KEY</code> label)"},{"location":"metrics/reference/#crossplane_xr_ready","title":"<code>crossplane_xr_ready</code>","text":"<p>Number of XRs with <code>status.conditions</code> containing <code>type: Ready</code> and <code>status: \"True\"</code>. Same label set as <code>crossplane_xr_total</code>.</p>"},{"location":"metrics/reference/#example-output","title":"Example output","text":"<p>Output from <code>curl localhost:8080/metrics</code> with sample resources applied:</p> <pre><code># HELP crossplane_claims_ready Number of Ready Crossplane claims by group, kind, namespace, composition and creator.\n# TYPE crossplane_claims_ready gauge\ncrossplane_claims_ready{composition=\"\",creator=\"alice@example.com\",group=\"samples.xptracker.dev\",kind=\"Gadget\",namespace=\"team-alpha\",team=\"platform\"} 0\ncrossplane_claims_ready{composition=\"\",creator=\"alice@example.com\",group=\"samples.xptracker.dev\",kind=\"Widget\",namespace=\"team-alpha\",team=\"platform\"} 0\ncrossplane_claims_ready{composition=\"\",creator=\"bob@example.com\",group=\"samples.xptracker.dev\",kind=\"Widget\",namespace=\"team-beta\",team=\"backend\"} 0\n\n# HELP crossplane_claims_total Number of Crossplane claims by group, kind, namespace, composition and creator.\n# TYPE crossplane_claims_total gauge\ncrossplane_claims_total{composition=\"\",creator=\"alice@example.com\",group=\"samples.xptracker.dev\",kind=\"Gadget\",namespace=\"team-alpha\",team=\"platform\"} 1\ncrossplane_claims_total{composition=\"\",creator=\"alice@example.com\",group=\"samples.xptracker.dev\",kind=\"Widget\",namespace=\"team-alpha\",team=\"platform\"} 2\ncrossplane_claims_total{composition=\"\",creator=\"bob@example.com\",group=\"samples.xptracker.dev\",kind=\"Widget\",namespace=\"team-beta\",team=\"backend\"} 1\n\n# HELP crossplane_xr_ready Number of Ready Crossplane XRs by group, kind, namespace and composition.\n# TYPE crossplane_xr_ready gauge\ncrossplane_xr_ready{composition=\"\",group=\"samples.xptracker.dev\",kind=\"XGadget\",namespace=\"\"} 0\ncrossplane_xr_ready{composition=\"\",group=\"samples.xptracker.dev\",kind=\"XWidget\",namespace=\"\"} 0\n\n# HELP crossplane_xr_total Number of Crossplane composite resources (XRs) by group, kind, namespace and composition.\n# TYPE crossplane_xr_total gauge\ncrossplane_xr_total{composition=\"\",group=\"samples.xptracker.dev\",kind=\"XGadget\",namespace=\"\"} 4\ncrossplane_xr_total{composition=\"\",group=\"samples.xptracker.dev\",kind=\"XWidget\",namespace=\"\"} 4\n</code></pre>"},{"location":"metrics/reference/#aggregation-behaviour","title":"Aggregation behaviour","text":"<p>Metrics are aggregated by their full label tuple. For example, if two claims in namespace <code>team-a</code> have the same group, kind, composition, creator, and team, they are counted as a single time series with value <code>2</code>.</p> <p>This means the cardinality is bounded by the number of unique label combinations, not the total number of resources.</p>"},{"location":"metrics/reference/#label-notes","title":"Label notes","text":"<ul> <li>Empty labels: if an annotation key is not configured or the annotation is not present on a resource, the label value is an empty string (<code>\"\"</code>).</li> <li>Composition enrichment: claims inherit their <code>composition</code> label from the backing XR via the <code>spec.resourceRef.name</code> linkage. If the claim has no resource reference yet, the composition will be empty.</li> <li>Namespace for XRs: composite resources are typically cluster-scoped, so the <code>namespace</code> label is usually empty.</li> </ul>"}]}